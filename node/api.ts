/* tslint:disable */
/* eslint-disable */
/**
 * pony.find clients backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Fandom
 */
export interface Fandom {
    /**
     * 
     * @type {string}
     * @memberof Fandom
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fandom
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fandom
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Fandom
     */
    'emoji'?: string;
    /**
     * 
     * @type {Image}
     * @memberof Fandom
     */
    'icon'?: Image;
}
/**
 * 
 * @export
 * @interface HistoryItem
 */
export interface HistoryItem {
    /**
     * 
     * @type {string}
     * @memberof HistoryItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryItem
     */
    'match_id'?: string;
    /**
     * 
     * @type {Profile}
     * @memberof HistoryItem
     */
    'profile'?: Profile;
    /**
     * 
     * @type {string}
     * @memberof HistoryItem
     */
    'action_type'?: HistoryItemActionTypeEnum;
}

export const HistoryItemActionTypeEnum = {
    Like: 'like',
    Dislike: 'dislike'
} as const;

export type HistoryItemActionTypeEnum = typeof HistoryItemActionTypeEnum[keyof typeof HistoryItemActionTypeEnum];

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'description'?: string;
    /**
     * 
     * @type {object}
     * @memberof ModelError
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * only for moderators usage
     * @type {string}
     * @memberof Profile
     */
    'user_id'?: string;
    /**
     * profile id shows only for owner or moderator
     * @type {string}
     * @memberof Profile
     */
    'id'?: string;
    /**
     * for matches routes usage
     * @type {string}
     * @memberof Profile
     */
    'match_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'birthdate'?: string;
    /**
     * 
     * @type {Array<Fandom>}
     * @memberof Profile
     */
    'fandoms'?: Array<Fandom>;
    /**
     * 
     * @type {Array<Image>}
     * @memberof Profile
     */
    'image'?: Array<Image>;
}
/**
 * 
 * @export
 * @interface ProfilesGet200Response
 */
export interface ProfilesGet200Response {
    /**
     * 
     * @type {Array<Profile>}
     * @memberof ProfilesGet200Response
     */
    'items': Array<Profile>;
    /**
     * 
     * @type {number}
     * @memberof ProfilesGet200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProfilesGet200Response
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ProfilesIdMatchesHistoryGet200Response
 */
export interface ProfilesIdMatchesHistoryGet200Response {
    /**
     * 
     * @type {Array<HistoryItem>}
     * @memberof ProfilesIdMatchesHistoryGet200Response
     */
    'items': Array<HistoryItem>;
    /**
     * 
     * @type {number}
     * @memberof ProfilesIdMatchesHistoryGet200Response
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ProfilesIdMatchesHistoryGet200Response
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ProfilesMatchesIdReportPostRequest
 */
export interface ProfilesMatchesIdReportPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfilesMatchesIdReportPostRequest
     */
    'reason': ProfilesMatchesIdReportPostRequestReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ProfilesMatchesIdReportPostRequest
     */
    'description'?: string;
}

export const ProfilesMatchesIdReportPostRequestReasonEnum = {
    Spam: 'spam',
    Advertising: 'advertising',
    Porn: 'porn',
    Custom: 'custom'
} as const;

export type ProfilesMatchesIdReportPostRequestReasonEnum = typeof ProfilesMatchesIdReportPostRequestReasonEnum[keyof typeof ProfilesMatchesIdReportPostRequestReasonEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user profiles
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('profilesGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('profilesGet', 'offset', offset)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive profile
         * @param {string} id Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesIdDelete', 'id', id)
            const localVarPath = `/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get profile by ID
         * @param {string} id Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesIdGet', 'id', id)
            const localVarPath = `/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dates for matched profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdMatchesDatesGet: async (id: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesIdMatchesDatesGet', 'id', id)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('profilesIdMatchesDatesGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('profilesIdMatchesDatesGet', 'offset', offset)
            const localVarPath = `/profiles/{id}/matches/dates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of matched profiles for a particular profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdMatchesGet: async (id: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesIdMatchesGet', 'id', id)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('profilesIdMatchesGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('profilesIdMatchesGet', 'offset', offset)
            const localVarPath = `/profiles/{id}/matches`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a history of matches for a specific profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdMatchesHistoryGet: async (id: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesIdMatchesHistoryGet', 'id', id)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('profilesIdMatchesHistoryGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('profilesIdMatchesHistoryGet', 'offset', offset)
            const localVarPath = `/profiles/{id}/matches/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update profile
         * @param {string} id Profile ID
         * @param {Profile} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdPatch: async (id: string, profile: Profile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesIdPatch', 'id', id)
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('profilesIdPatch', 'profile', profile)
            const localVarPath = `/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dislike the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdDislikePost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesMatchesIdDislikePost', 'id', id)
            const localVarPath = `/profiles/matches/{id}/dislike`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific profile match by ID
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesMatchesIdGet', 'id', id)
            const localVarPath = `/profiles/matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdLikePost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesMatchesIdLikePost', 'id', id)
            const localVarPath = `/profiles/matches/{id}/like`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report the profile match
         * @param {string} id Match ID
         * @param {ProfilesMatchesIdReportPostRequest} profilesMatchesIdReportPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdReportPost: async (id: string, profilesMatchesIdReportPostRequest: ProfilesMatchesIdReportPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesMatchesIdReportPost', 'id', id)
            // verify required parameter 'profilesMatchesIdReportPostRequest' is not null or undefined
            assertParamExists('profilesMatchesIdReportPost', 'profilesMatchesIdReportPostRequest', profilesMatchesIdReportPostRequest)
            const localVarPath = `/profiles/matches/{id}/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profilesMatchesIdReportPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skip the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdSkipPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profilesMatchesIdSkipPost', 'id', id)
            const localVarPath = `/profiles/matches/{id}/skip`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new profile
         * @param {Profile} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost: async (profile: Profile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('profilesPost', 'profile', profile)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user profiles
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesGet(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Archive profile
         * @param {string} id Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get profile by ID
         * @param {string} id Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get dates for matched profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesIdMatchesDatesGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdMatchesDatesGet(id, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesIdMatchesDatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of matched profiles for a particular profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesIdMatchesGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdMatchesGet(id, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesIdMatchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a history of matches for a specific profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesIdMatchesHistoryGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesIdMatchesHistoryGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdMatchesHistoryGet(id, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesIdMatchesHistoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update profile
         * @param {string} id Profile ID
         * @param {Profile} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesIdPatch(id: string, profile: Profile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdPatch(id, profile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dislike the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesMatchesIdDislikePost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesMatchesIdDislikePost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesMatchesIdDislikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific profile match by ID
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesMatchesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesMatchesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesMatchesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Like the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesMatchesIdLikePost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesMatchesIdLikePost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesMatchesIdLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Report the profile match
         * @param {string} id Match ID
         * @param {ProfilesMatchesIdReportPostRequest} profilesMatchesIdReportPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesMatchesIdReportPost(id: string, profilesMatchesIdReportPostRequest: ProfilesMatchesIdReportPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesMatchesIdReportPost(id, profilesMatchesIdReportPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesMatchesIdReportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Skip the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesMatchesIdSkipPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesMatchesIdSkipPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesMatchesIdSkipPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new profile
         * @param {Profile} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesPost(profile: Profile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesPost(profile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.profilesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user profiles
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<ProfilesGet200Response> {
            return localVarFp.profilesGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive profile
         * @param {string} id Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profilesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get profile by ID
         * @param {string} id Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.profilesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dates for matched profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdMatchesDatesGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<ProfilesGet200Response> {
            return localVarFp.profilesIdMatchesDatesGet(id, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of matched profiles for a particular profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdMatchesGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<ProfilesGet200Response> {
            return localVarFp.profilesIdMatchesGet(id, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a history of matches for a specific profile
         * @param {string} id Profile ID
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdMatchesHistoryGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<ProfilesIdMatchesHistoryGet200Response> {
            return localVarFp.profilesIdMatchesHistoryGet(id, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update profile
         * @param {string} id Profile ID
         * @param {Profile} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesIdPatch(id: string, profile: Profile, options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.profilesIdPatch(id, profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dislike the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdDislikePost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profilesMatchesIdDislikePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific profile match by ID
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.profilesMatchesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Like the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdLikePost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profilesMatchesIdLikePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Report the profile match
         * @param {string} id Match ID
         * @param {ProfilesMatchesIdReportPostRequest} profilesMatchesIdReportPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdReportPost(id: string, profilesMatchesIdReportPostRequest: ProfilesMatchesIdReportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profilesMatchesIdReportPost(id, profilesMatchesIdReportPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Skip the profile match
         * @param {string} id Match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesMatchesIdSkipPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profilesMatchesIdSkipPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new profile
         * @param {Profile} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost(profile: Profile, options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.profilesPost(profile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get current user profiles
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesGet(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive profile
     * @param {string} id Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get profile by ID
     * @param {string} id Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dates for matched profile
     * @param {string} id Profile ID
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesIdMatchesDatesGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesIdMatchesDatesGet(id, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of matched profiles for a particular profile
     * @param {string} id Profile ID
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesIdMatchesGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesIdMatchesGet(id, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a history of matches for a specific profile
     * @param {string} id Profile ID
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesIdMatchesHistoryGet(id: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesIdMatchesHistoryGet(id, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update profile
     * @param {string} id Profile ID
     * @param {Profile} profile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesIdPatch(id: string, profile: Profile, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesIdPatch(id, profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dislike the profile match
     * @param {string} id Match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesMatchesIdDislikePost(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesMatchesIdDislikePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific profile match by ID
     * @param {string} id Match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesMatchesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesMatchesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Like the profile match
     * @param {string} id Match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesMatchesIdLikePost(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesMatchesIdLikePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Report the profile match
     * @param {string} id Match ID
     * @param {ProfilesMatchesIdReportPostRequest} profilesMatchesIdReportPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesMatchesIdReportPost(id: string, profilesMatchesIdReportPostRequest: ProfilesMatchesIdReportPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesMatchesIdReportPost(id, profilesMatchesIdReportPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Skip the profile match
     * @param {string} id Match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesMatchesIdSkipPost(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesMatchesIdSkipPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new profile
     * @param {Profile} profile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profilesPost(profile: Profile, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).profilesPost(profile, options).then((request) => request(this.axios, this.basePath));
    }
}



